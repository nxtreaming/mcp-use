---
title: "Resources"
description: "Read content and data from MCP servers"
icon: "folder-open"
---

Resources provide URI-based access to content and data exposed by MCP servers. They enable your applications to read configuration files, documentation, database records, API responses, and any other information that servers want to make available.

## Understanding Resources

In the MCP protocol, resources are content sources that clients can read via URIs. Each resource has:

- **Unique URI**: Resources are identified and accessed by unique URIs
- **Content types**: Support for text, JSON, binary, and other MIME types
- **Static or dynamic**: Content can be fixed or generated on-demand
- **Template support**: Parameterized resources for dynamic content generation

<Tip>
**Think of resources as endpoints**: Just like REST APIs have endpoints, MCP servers expose resources via URIs. The key difference is that resources are designed for AI context and can include rich metadata.
</Tip>

## Types of Resources

### Direct Resources
Static resources with fixed URIs that always return the same type of content.

### Resource Templates
Dynamic resources that accept parameters to generate different content based on input.

## Listing Available Resources

To see what resources are available from a connected MCP server:

<CodeGroup>
```typescript TypeScript
import { MCPClient } from 'mcp-use'

async function listResources() {
    // Initialize client with server configuration
    const config = {
        mcpServers: {
            // Your server definitions here
        }
    }
    const client = new MCPClient(config)

    // Connect to servers
    await client.createAllSessions()

    // Get a session for a specific server
    const session = client.getSession('my_server')

    // List all available resources - always returns fresh data
    const resources = await session.listResources()

    for (const resource of resources) {
        console.log(`Resource: ${resource.name}`)
        console.log(`URI: ${resource.uri}`)
        console.log(`Description: ${resource.description}`)
        console.log(`MIME Type: ${resource.mimeType}`)
        console.log('---')
    }

    await client.closeAllSessions()
}

// Run the example
listResources().catch(console.error)
```

```typescript TypeScript
import { MCPClient } from 'mcp-use'

async function listResources() {
    // Initialize client with server configuration
    const config = {
        mcpServers: {
            // Your server definitions here
        }
    }
    const client = new MCPClient(config)

    // Connect to servers
    await client.createAllSessions()

    // Get a session for a specific server
    const session = client.getSession('my_server')

    // List all available resources - always returns fresh data
    const resources = await session.listResources()

    for (const resource of resources) {
        console.log(`Resource: ${resource.name}`)
        console.log(`URI: ${resource.uri}`)
        console.log(`Description: ${resource.description}`)
        console.log(`MIME Type: ${resource.mimeType}`)
        console.log('---')
    }

    await client.closeAllSessions()
}

// Run the example
listResources().catch(console.error)
```
</CodeGroup>

### Dynamic Resource Lists

<Info>
Resources can be added, removed, or modified at runtime. Servers notify clients of changes via `ResourceListChangedNotification`, ensuring your application always has access to the latest available resources.
</Info>

Always use `listResources()` to get fresh data from the server:

<CodeGroup>
```typescript TypeScript
// ✅ Recommended - always returns fresh data
const resources = await session.listResources()

// ⚠️ Deprecated - may return stale data
// const resources = session.resources
```

```typescript TypeScript
// ✅ Recommended - always returns fresh data
const resources = await session.listResources()

// ⚠️ Deprecated - may return stale data
// const resources = session.resources
```
</CodeGroup>

## Reading Resources

Resources are accessed using the `read_resource` method with their URI:

<CodeGroup>
```typescript TypeScript
import { MCPClient } from 'mcp-use'

async function readResourceExample() {
    const config = {
        mcpServers: {
            // Your server definitions here
        }
    }
    const client = new MCPClient(config)
    await client.createAllSessions()

    const session = client.getSession('file_server')

    // Read a resource by URI
    const resourceUri = 'file:///path/to/config.json'
    const result = await session.readResource(resourceUri)

    // Handle the result
    for (const content of result.contents) {
        if (content.mimeType === 'application/json') {
            console.log(`JSON content: ${content.text}`)
        } else if (content.mimeType === 'text/plain') {
            console.log(`Text content: ${content.text}`)
        } else {
            console.log(`Binary content length: ${content.blob?.length}`)
        }
    }

    await client.closeAllSessions()
}

readResourceExample().catch(console.error)
```

```typescript TypeScript
import { MCPClient } from 'mcp-use'

async function readResourceExample() {
    const config = {
        mcpServers: {
            // Your server definitions here
        }
    }
    const client = new MCPClient(config)
    await client.createAllSessions()

    const session = client.getSession('file_server')

    // Read a resource by URI
    const resourceUri = 'file:///path/to/config.json'
    const result = await session.readResource(resourceUri)

    // Handle the result
    for (const content of result.contents) {
        if (content.mimeType === 'application/json') {
            console.log(`JSON content: ${content.text}`)
        } else if (content.mimeType === 'text/plain') {
            console.log(`Text content: ${content.text}`)
        } else {
            console.log(`Binary content length: ${content.blob?.length}`)
        }
    }

    await client.closeAllSessions()
}

readResourceExample().catch(console.error)
```
</CodeGroup>

## Working with Resource Templates

Resource templates allow dynamic content generation based on parameters:

<CodeGroup>
```typescript TypeScript
import { MCPClient } from 'mcp-use'

async function templateResourceExample() {
    const config = {
        mcpServers: {
            // Your server definitions here
        }
    }
    const client = new MCPClient(config)
    await client.createAllSessions()

    const session = client.getSession('database_server')

    // Access a parameterized resource
    // Template URI might be: "db://users/{user_id}/profile"
    const resourceUri = 'db://users/12345/profile'
    const result = await session.readResource(resourceUri)

    // Process the user profile data
    for (const content of result.contents) {
        console.log(`User profile: ${content.text}`)
    }

    await client.closeAllSessions()
}

templateResourceExample().catch(console.error)
```

```typescript TypeScript
import { MCPClient } from 'mcp-use'

async function templateResourceExample() {
    const config = {
        mcpServers: {
            // Your server definitions here
        }
    }
    const client = new MCPClient(config)
    await client.createAllSessions()

    const session = client.getSession('database_server')

    // Access a parameterized resource
    // Template URI might be: "db://users/{user_id}/profile"
    const resourceUri = 'db://users/12345/profile'
    const result = await session.readResource(resourceUri)

    // Process the user profile data
    for (const content of result.contents) {
        console.log(`User profile: ${content.text}`)
    }

    await client.closeAllSessions()
}

templateResourceExample().catch(console.error)
```
</CodeGroup>

## Resource Content Types

Resources can contain different types of content:

### Text Content

<CodeGroup>
```typescript TypeScript
// Text-based resources (JSON, XML, plain text)
const result = await session.readResource('file:///config.json')

for (const content of result.contents) {
    if ('text' in content) {
        console.log(`Text content: ${content.text}`)
        console.log(`MIME type: ${content.mimeType}`)
    }
}
```

```typescript TypeScript
// Text-based resources (JSON, XML, plain text)
const result = await session.readResource('file:///config.json')

for (const content of result.contents) {
    if ('text' in content) {
        console.log(`Text content: ${content.text}`)
        console.log(`MIME type: ${content.mimeType}`)
    }
}
```
</CodeGroup>

### Binary Content

<CodeGroup>
```typescript TypeScript
import { writeFileSync } from 'fs'

// Binary resources (images, files, etc.)
const result = await session.readResource('file:///image.png')

for (const content of result.contents) {
    if ('blob' in content && content.blob) {
        console.log(`Binary data size: ${content.blob.length} bytes`)
        // Save or process binary data
        writeFileSync('downloaded_image.png', Buffer.from(content.blob))
    }
}
```

```typescript TypeScript
import { writeFileSync } from 'fs'

// Binary resources (images, files, etc.)
const result = await session.readResource('file:///image.png')

for (const content of result.contents) {
    if ('blob' in content && content.blob) {
        console.log(`Binary data size: ${content.blob.length} bytes`)
        // Save or process binary data
        writeFileSync('downloaded_image.png', Buffer.from(content.blob))
    }
}
```
</CodeGroup>

## Resource Discovery

Find resources matching specific criteria:

<CodeGroup>
```typescript TypeScript
async function findResources() {
    const session = client.getSession('my_server')
    const resources = await session.listResources()

    // Find JSON configuration files
    const configResources = resources.filter(
        r => r.mimeType === 'application/json'
            && r.name.toLowerCase().includes('config')
    )

    for (const resource of configResources) {
        console.log(`Found config: ${resource.name} at ${resource.uri}`)
    }
}
```

```typescript TypeScript
async function findResources() {
    const session = client.getSession('my_server')
    const resources = await session.listResources()

    // Find JSON configuration files
    const configResources = resources.filter(
        r => r.mimeType === 'application/json'
            && r.name.toLowerCase().includes('config')
    )

    for (const resource of configResources) {
        console.log(`Found config: ${resource.name} at ${resource.uri}`)
    }
}
```
</CodeGroup>

## Error Handling

Always handle potential errors when reading resources:

<CodeGroup>
```typescript TypeScript
try {
    const result = await session.readResource('file:///missing.txt')
    for (const content of result.contents) {
        console.log(`Content: ${content.text}`)
    }
} catch (error) {
    console.error(`Failed to read resource: ${error}`)
}
```

```typescript TypeScript
try {
    const result = await session.readResource('file:///missing.txt')
    for (const content of result.contents) {
        console.log(`Content: ${content.text}`)
    }
} catch (error) {
    console.error(`Failed to read resource: ${error}`)
}
```
</CodeGroup>
