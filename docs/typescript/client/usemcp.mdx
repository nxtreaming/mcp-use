---
title: "useMcp Hook"
description: "React integration for MCP client connections"
icon: "react"
tag: "New"
---

The `useMcp` React hook provides a complete, batteries-included solution for connecting React applications to MCP servers. It manages connections, authentication, tool calls, and state synchronization automatically.

## Features

The hook provides:

- **Automatic connection management**: Handles connect, disconnect, and reconnect
- **OAuth support**: Complete OAuth flow with token management
- **Tool execution**: Call tools with automatic error handling
- **Real-time state**: Reactive state updates for UI synchronization
- **Type safety**: Full TypeScript support with automatic type inference

<Tip>
**Perfect for React Apps**: The hook handles all the complexity of MCP connections, letting you focus on building your UI. Just call `useMcp()` and you're ready to go.
</Tip>

## Basic Usage

```typescript
import { useMcp } from 'mcp-use/react'

function MyComponent() {
  const mcp = useMcp({
    url: 'http://localhost:3000/mcp',
    customHeaders: {
      Authorization: 'Bearer YOUR_API_KEY'
    }
  })

  // Wait for connection
  if (mcp.state !== 'ready') {
    return <div>Connecting...</div>
  }

  // Show available tools
  return (
    <div>
      <h2>Available Tools</h2>
      <ul>
        {mcp.tools.map(tool => (
          <li key={tool.name}>{tool.name}: {tool.description}</li>
        ))}
      </ul>
    </div>
  )
}
```

## Connection States

The hook manages connection state automatically:

```typescript
const mcp = useMcp({ url })

// State progression:
// 'discovering' ‚Üí Initial state, attempting connection
// 'authenticating' ‚Üí OAuth flow in progress
// 'pending_auth' ‚Üí Waiting for user to approve OAuth
// 'ready' ‚Üí Connected and ready to use
// 'failed' ‚Üí Connection failed (check mcp.error)
```

Handling Connection States

```typescript
function ConnectionStatus() {
  const mcp = useMcp({ url: 'http://localhost:3000/mcp' })

  switch (mcp.state) {
    case 'discovering':
      return <Spinner>Connecting...</Spinner>

    case 'authenticating':
      return <div>Authenticating... Check for popup window</div>

    case 'pending_auth':
      return (
        <button onClick={mcp.authenticate}>
          Click to Authenticate
        </button>
      )

    case 'ready':
      return <div>‚úÖ Connected ({mcp.tools.length} tools available)</div>

    case 'failed':
      return (
        <div>
          ‚ùå Connection failed: {mcp.error}
          <button onClick={mcp.retry}>Retry</button>
        </div>
      )
  }
}
```

## Configuration Options

```typescript
interface UseMcpOptions {
  // Connection
  url?: string                             // MCP server URL (optional)
  enabled?: boolean                        // Enable/disable connection (default: true)
  customHeaders?: Record<string, string>   // Custom headers (auth, etc.)
  transportType?: 'auto' | 'http' | 'sse'  // Transport preference (default: 'auto')
  timeout?: number                         // Connection timeout (ms, default: 30000)
  sseReadTimeout?: number                  // SSE read timeout (ms, default: 300000)

  // OAuth
  clientName?: string                      // OAuth client name
  clientUri?: string                       // OAuth client URI
  callbackUrl?: string                     // OAuth callback URL (default: /oauth/callback)
  preventAutoAuth?: boolean                // Prevent automatic OAuth (show auth button, default: false)
  useRedirectFlow?: boolean                // Use redirect instead of popup (default: false)
  onPopupWindow?: (url: string, features: string, window: Window | null) => void    // OAuth popup handler
  storageKeyPrefix?: string                // localStorage key prefix (default: 'mcp:auth')

  // Reconnection
  autoRetry?: boolean | number             // Auto-retry on failure (boolean or delay in ms)
  autoReconnect?: boolean | number         // Auto-reconnect on drop (boolean or delay in ms, default: 3000)

  // Client info
  clientConfig?: {
    name?: string                          // Client name
    version?: string                       // Client version
  }

  // Advanced
  debug?: boolean                          // Enable verbose debug logging
  popupFeatures?: string                   // OAuth popup window features string
  wrapTransport?: (transport: any, serverId: string) => any  // Transport wrapper for interceptors

  // Callbacks
  onNotification?: (notification: Notification) => void  // Handle server notifications
  samplingCallback?: (params: CreateMessageRequest["params"]) => Promise<CreateMessageResult>  // Handle sampling requests
  onElicitation?: (params: ElicitRequestFormParams | ElicitRequestURLParams) => Promise<ElicitResult>  // Handle elicitation requests
}
```

## Authentication

### Bearer Token

```typescript
const mcp = useMcp({
  url: 'http://localhost:3000/mcp',
  customHeaders: {
    Authorization: 'Bearer YOUR_API_KEY'
  }
})
```

### OAuth

mcp-use supports two OAuth flow modes:

**Popup Flow**

Opens OAuth in a popup window. Best for web applications.

```typescript
const mcp = useMcp({
  url: 'https://mcp.linear.app/mcp',
  clientName: 'My App',
  callbackUrl: window.location.origin + '/oauth/callback',
  // Popup flow is default
  onPopupWindow: (popup) => {
    // Track popup for UX
    console.log('OAuth popup opened:', popup)
  }
})

// OAuth handled automatically:
// 1. Server returns 401 with WWW-Authenticate
// 2. SDK triggers OAuth popup
// 3. User authorizes in popup
// 4. Popup redirects to callback
// 5. Connection retries with token
```

**Redirect Flow**

Redirects the main window. Best for mobile or when popups are blocked.

```typescript
const mcp = useMcp({
  url: 'https://mcp.linear.app/mcp',
  clientName: 'My App',
  callbackUrl: window.location.origin + '/oauth/callback',
  useRedirectFlow: true // Enable redirect flow
})
```

**Manual Authentication Trigger**

Prevent automatic OAuth and show a manual login button:

```typescript
function MyComponent() {
  const mcp = useMcp({
    url: 'https://mcp.linear.app/mcp',
    preventAutoAuth: true // Don't auto-trigger OAuth
  })

  if (mcp.state === 'pending_auth') {
    return (
      <button onClick={mcp.authenticate}>
        Sign in to Linear
      </button>
    )
  }

  if (mcp.state === 'authenticating') {
    return <div>Authenticating...</div>
  }

  // ... rest of component
}
```

### OAuth Callback Page

Create an OAuth callback route to handle OAuth redirects:

```typescript
// app/oauth/callback/page.tsx (Next.js App Router)
// or pages/oauth/callback.tsx (Next.js Pages Router)
import { onMcpAuthorization } from 'mcp-use/auth'
// Also available from: import { onMcpAuthorization } from 'mcp-use/react'
import { useEffect } from 'react'

export default function OAuthCallback() {
  useEffect(() => {
    // The function handles everything internally:
    // - Displays success/error UI directly in this callback window
    // - Posts message to opener window for popup flow
    // - Automatically redirects for redirect flow
    // - No need for error handling - it's handled internally
    onMcpAuthorization()
  }, [])

  // Simple loading state while processing
  return <div>Processing authentication...</div>
}
```

<Note>
The `onMcpAuthorization()` function handles all success and error cases internally. For popup flow, it posts a message to the opener window (which `useMcp` listens for automatically). For redirect flow, it handles the navigation. You don't need custom error handling in your callback component.
</Note>

## Calling Tools

```typescript
function ToolExecutor() {
  const mcp = useMcp({ url: 'http://localhost:3000/mcp' })
  const [result, setResult] = useState(null)

  const handleSendEmail = async () => {
    try {
      const result = await mcp.callTool('send-email', {
        to: 'user@example.com',
        subject: 'Hello',
        body: 'Test message'
      })
      setResult(result)
    } catch (error) {
      console.error('Tool call failed:', error)
    }
  }

  return (
    <div>
      <button onClick={handleSendEmail} disabled={mcp.state !== 'ready'}>
        Send Email
      </button>
      {result && <pre>{JSON.stringify(result, null, 2)}</pre>}
    </div>
  )
}
```

## Reading Resources

```typescript
function ResourceViewer({ uri }: { uri: string }) {
  const mcp = useMcp({ url: 'http://localhost:3000/mcp' })
  const [content, setContent] = useState('')

  useEffect(() => {
    if (mcp.state === 'ready') {
      mcp.readResource(uri).then(resource => {
        setContent(resource.contents[0].text)
      })
    }
  }, [mcp.state, uri])

  return (
    <div>
      <h3>Resource: {uri}</h3>
      <pre>{content}</pre>
    </div>
  )
}
```

## Listing Resources and Prompts

```typescript
function ServerExplorer() {
  const mcp = useMcp({ url: 'http://localhost:3000/mcp' })

  const handleListResources = async () => {
    await mcp.listResources()
    // Updates mcp.resources state
  }

  const handleListPrompts = async () => {
    await mcp.listPrompts()
    // Updates mcp.prompts state
  }

  return (
    <div>
      <button onClick={handleListResources}>Refresh Resources</button>
      <button onClick={handleListPrompts}>Refresh Prompts</button>

      <h3>Resources ({mcp.resources.length})</h3>
      <ul>
        {mcp.resources.map(r => (
          <li key={r.uri}>{r.name || r.uri}</li>
        ))}
      </ul>

      <h3>Prompts ({mcp.prompts.length})</h3>
      <ul>
        {mcp.prompts.map(p => (
          <li key={p.name}>{p.name}: {p.description}</li>
        ))}
      </ul>
    </div>
  )
}
```

## AI Chat with MCP Tools

The `useMcp` hook exposes the underlying `client` which you can use to create an AI agent with access to all MCP tools.

<Note>
**For browser apps**: Use dynamic import of `mcp-use/browser` (shown below) to avoid bundling server-side code.
**For Node.js apps**: You can import directly from `mcp-use`.
</Note>

```typescript
import { useMcp } from 'mcp-use/react'
import { ChatOpenAI } from '@langchain/openai'
import { useState, useMemo, useEffect } from 'react'

function ChatInterface() {
  const mcp = useMcp({
    url: 'http://localhost:3000/mcp',
    customHeaders: { Authorization: 'Bearer YOUR_API_KEY' }
  })

  const [agent, setAgent] = useState(null)
  const [messages, setMessages] = useState<Array<{role: string, content: string}>>([])
  const [input, setInput] = useState('')
  const [isLoading, setIsLoading] = useState(false)

  // Create LLM instance
  const llm = useMemo(() => new ChatOpenAI({
    model: 'gpt-4',
    apiKey: process.env.OPENAI_API_KEY,
    temperature: 0.7
  }), [])

  // Create agent when connection is ready
  useEffect(() => {
    if (mcp.state === 'ready' && mcp.client && !agent) {
      // Use dynamic import for browser environments to avoid bundling server-side code
      import('mcp-use/browser').then(({ MCPAgent }) => {
        const newAgent = new MCPAgent({
          llm,
          client: mcp.client,
          memoryEnabled: true,
          systemPrompt: 'You are a helpful assistant.'
        })
        newAgent.initialize().then(() => setAgent(newAgent))
      })
    }
  }, [mcp.state, mcp.client, llm])

  const handleSend = async () => {
    if (!input.trim() || !agent) return

    const userMessage = { role: 'user', content: input }
    setMessages(prev => [...prev, userMessage])
    setInput('')
    setIsLoading(true)

    try {
      let assistantContent = ''

      // Stream response from AI agent
      for await (const event of agent.streamEvents(input)) {
        // Handle streaming text
        if (event.event === 'on_chat_model_stream' && event.data?.chunk?.text) {
          assistantContent += event.data.chunk.text

          // Update UI with streaming text
          setMessages(prev => {
            const last = prev[prev.length - 1]
            if (last?.role === 'assistant') {
              return [
                ...prev.slice(0, -1),
                { role: 'assistant', content: assistantContent }
              ]
            }
            return [...prev, { role: 'assistant', content: assistantContent }]
          })
        }

        // Handle tool calls
        if (event.event === 'on_tool_start') {
          console.log('Using tool:', event.name)
        }
      }
    } catch (error) {
      console.error('Chat error:', error)
      setMessages(prev => [...prev, {
        role: 'assistant',
        content: `Error: ${error.message}`
      }])
    } finally {
      setIsLoading(false)
    }
  }

  const handleClearHistory = () => {
    if (agent) {
      agent.clearConversationHistory()
      setMessages([])
    }
  }

  return (
    <div>
      <div className="messages">
        {messages.map((msg, i) => (
          <div key={i} className={msg.role}>
            <strong>{msg.role}:</strong> {msg.content}
          </div>
        ))}
      </div>

      <input
        value={input}
        onChange={e => setInput(e.target.value)}
        onKeyDown={e => e.key === 'Enter' && handleSend()}
        disabled={isLoading || !agent}
      />

      <button onClick={handleSend} disabled={isLoading || !agent}>
        {isLoading ? 'Sending...' : 'Send'}
      </button>

      <button onClick={handleClearHistory} disabled={!agent}>
        Clear History
      </button>
    </div>
  )
}
```

**Key features:**
- üß† **Conversation memory**: The agent remembers previous messages (set `memoryEnabled: true`)
- üõ†Ô∏è **Automatic tool access**: Agent can call any MCP tool from the connected server
- ‚ö° **Streaming responses**: Real-time token streaming for better UX
- üîÑ **Agent persistence**: Reuse the same agent across messages for memory

MCPAgent works with any LangChain chat model:

```typescript
// OpenAI
import { ChatOpenAI } from '@langchain/openai'
const llm = new ChatOpenAI({
  model: 'gpt-4',
  apiKey: process.env.OPENAI_API_KEY
})

// Anthropic
import { ChatAnthropic } from '@langchain/anthropic'
const llm = new ChatAnthropic({
  model: 'claude-3-5-sonnet-20241022',
  apiKey: process.env.ANTHROPIC_API_KEY
})

// Google
import { ChatGoogleGenerativeAI } from '@langchain/google-genai'
const llm = new ChatGoogleGenerativeAI({
  model: 'gemini-pro',
  apiKey: process.env.GOOGLE_API_KEY
})

// Or any other LangChain-compatible model
import { ChatOllama } from '@langchain/community/chat_models/ollama'
const llm = new ChatOllama({ model: 'llama2' })
```

## Error Handling

```typescript
function RobustConnection() {
  const mcp = useMcp({
    url: 'http://localhost:3000/mcp',
    autoRetry: 5000,  // Auto-retry every 5 seconds on failure
  })

  // Monitor errors
  useEffect(() => {
    if (mcp.state === 'failed') {
      console.error('Connection failed:', mcp.error)

      // Common errors:
      if (mcp.error?.includes('401')) {
        alert('Add your Authorization header in settings')
      } else if (mcp.error?.includes('ECONNREFUSED')) {
        alert('Server is not running on ' + url)
      }
    }
  }, [mcp.state, mcp.error])

  return (
    <div>
      {mcp.state === 'failed' && (
        <div className="error">
          {mcp.error}
          <button onClick={mcp.retry}>Retry Connection</button>
        </div>
      )}
    </div>
  )
}
```


## API Reference

### State Properties

| Property | Type | Description |
|----------|------|-------------|
| `state` | `'discovering' \| 'authenticating' \| 'pending_auth' \| 'ready' \| 'failed'` | Current connection state |
| `tools` | `Tool[]` | Available tools from the server |
| `resources` | `Resource[]` | Available resources |
| `resourceTemplates` | `ResourceTemplate[]` | Available resource templates |
| `prompts` | `Prompt[]` | Available prompt templates |
| `serverInfo` | `{ name: string; version?: string } \| undefined` | Server information from initialize response |
| `capabilities` | `Record<string, any> \| undefined` | Server capabilities from initialize response |
| `error` | `string \| undefined` | Error message if connection failed |
| `log` | `Array<{level, message, timestamp}>` | Connection log entries |
| `authUrl` | `string \| undefined` | OAuth authorization URL (if manual auth needed) |
| `client` | `BrowserMCPClient \| null` | Underlying client instance for creating agents |

### Methods

#### `callTool(name, args, options?)`

Execute a tool on the MCP server with optional timeout configuration.

**Parameters:**
- `name: string` - Tool name to execute
- `args?: Record<string, unknown>` - Tool arguments
- `options?` - Optional configuration:
  - `timeout?: number` - Request timeout in milliseconds (default: 60000)
  - `maxTotalTimeout?: number` - Maximum total timeout even with progress resets
  - `resetTimeoutOnProgress?: boolean` - Reset timeout when progress notifications received
  - `signal?: AbortSignal` - AbortSignal for request cancellation

```typescript
// Basic tool call
const result = await mcp.callTool('tool-name', {
  param1: 'value1',
  param2: 'value2'
})

// Tool call with extended timeout (useful for long-running tools or sampling)
const result = await mcp.callTool('analyze-data', { dataset: 'large' }, {
  timeout: 300000,              // 5 minutes
  resetTimeoutOnProgress: true  // Reset timer on progress updates
})

// Tool call with abort signal
const controller = new AbortController()
const result = await mcp.callTool('query', { search: 'term' }, {
  signal: controller.signal
})
// Later: controller.abort()
```

#### `readResource(uri)`

Read a resource by URI.

```typescript
const resource = await mcp.readResource('file:///path/to/file')
console.log(resource.contents[0].text)
```

#### `listResources()`

Refresh the list of available resources.

```typescript
await mcp.listResources()
// mcp.resources is now updated
```

#### `listPrompts()`

Refresh the list of available prompts.

```typescript
await mcp.listPrompts()
// mcp.prompts is now updated
```

#### `getPrompt(name, args)`

Get a prompt template with arguments.

```typescript
const prompt = await mcp.getPrompt('code-review', {
  language: 'typescript',
  focus: 'security'
})
console.log(prompt.messages)
```

#### `client`

The underlying BrowserMCPClient instance. Use this to create an MCPAgent for AI chat functionality.

```typescript
import { ChatOpenAI } from '@langchain/openai'

const mcp = useMcp({ url: 'http://localhost:3000/mcp' })

// For browser environments, use dynamic import
const { MCPAgent } = await import('mcp-use/browser')

// Create agent with the exposed client
const agent = new MCPAgent({
  llm: new ChatOpenAI({ model: 'gpt-4' }),
  client: mcp.client,
  memoryEnabled: true
})

await agent.initialize()

// Use agent for chat
for await (const event of agent.streamEvents('Send an email')) {
  console.log(event)
}

// Clear conversation history
agent.clearConversationHistory()
```

**Note**: Use `import('mcp-use/browser')` for browser apps to avoid bundling server-side connectors (stdio, etc.).

#### `retry()`

Manually retry connection after failure.

```typescript
if (mcp.state === 'failed') {
  mcp.retry()
}
```

#### `disconnect()`

Disconnect from the server.

```typescript
await mcp.disconnect()
```

#### `authenticate()`

Trigger manual OAuth authentication flow.

```typescript
if (mcp.state === 'pending_auth') {
  mcp.authenticate()  // Opens OAuth popup
}
```

#### `clearStorage()`

Clear OAuth tokens and disconnect.

```typescript
mcp.clearStorage()  // Removes tokens from localStorage
```


## Next Steps

- [Authentication](/typescript/client/authentication) - OAuth and custom auth setup
- [MCPClient](/typescript/client/client-configuration) - Multi-server class-based client
- [Building Agents](/typescript/agent) - AI agents with MCP tools
- [Client Configuration](/typescript/client/client-configuration) - HTTP, SSE, stdio connection types
